var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = JSX","category":"page"},{"location":"#JSX","page":"Home","title":"JSX","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for JSX.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [JSX]","category":"page"},{"location":"#JSX.JSX","page":"Home","title":"JSX.JSX","text":"HTML parsing on steroids!\n\nIt's basically a tree traversal!\n\n\n\n\n\n","category":"module"},{"location":"#JSX.Node","page":"Home","title":"JSX.Node","text":"Node{T}\n\nA node in the tree.\n\n\n\n\n\n","category":"type"},{"location":"#JSX.findlimit","page":"Home","title":"JSX.findlimit","text":"Find the position where the content ends.\n\n\n\n\n\n","category":"function"},{"location":"#JSX.hasfinished","page":"Home","title":"JSX.hasfinished","text":"Check whether we have reached the end of the current tag.\n\n\n\n\n\n","category":"function"},{"location":"#JSX.isblank-Tuple{Any}","page":"Home","title":"JSX.isblank","text":"Check if a string is empty of pure whitespace.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.literalorquote-Tuple{AbstractString}","page":"Home","title":"JSX.literalorquote","text":"Attempt to parse a literal value, or quote and return a string.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.parse!","page":"Home","title":"JSX.parse!","text":"Parse a tree by modifying the a dummy node.\n\n\n\n\n\n","category":"function"},{"location":"#JSX.parse-Tuple{AbstractString}","page":"Home","title":"JSX.parse","text":"Parse a tree.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.processattr-Tuple{Pair, Any}","page":"Home","title":"JSX.processattr","text":"Process and normalize attributes.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.pushexprorstr!-Tuple{AbstractVector{T} where T, Any}","page":"Home","title":"JSX.pushexprorstr!","text":"Push strings only if the last object in the vector is not a string, concatenate otherwise. This ensures strings are as long as possible.\n\nWe also ensure the \"$(Expr(:incomplete, \"incomplete: invalid string syntax\"))\n\n\n\n\n\n","category":"method"},{"location":"#JSX.pushorappend!-Tuple{AbstractVector{T} where T, Any}","page":"Home","title":"JSX.pushorappend!","text":"Append if vector, push otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.toexpr-Tuple{JSX.Node, JSX.BranchNodeContext}","page":"Home","title":"JSX.toexpr","text":"Create a generic expression for a branch node.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.toexpr-Tuple{JSX.Node, JSX.ComponentNodeContext}","page":"Home","title":"JSX.toexpr","text":"Create a generic expression for a component node.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.toexpr-Tuple{JSX.Node, JSX.LeafCommonNodeContext}","page":"Home","title":"JSX.toexpr","text":"Create a generic expression for a leaf node.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.toexpr-Tuple{JSX.Node, JSX.NodeContext}","page":"Home","title":"JSX.toexpr","text":"Construct an expression that evaluates to the given node.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.trycatchexpr-Tuple{Any, Any}","page":"Home","title":"JSX.trycatchexpr","text":"Wrap an expression in a try...catch block.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.vec2expr-Tuple{AbstractVector{T} where T}","page":"Home","title":"JSX.vec2expr","text":"Recreate a vector as an expression. Optionally, apply a function to each element beforehand.\n\n\n\n\n\n","category":"method"},{"location":"#JSX.@htm_str-Tuple{Any}","page":"Home","title":"JSX.@htm_str","text":"Time to create a macro!\n\nWe want to do the following.\n\nExamples\n\njulia> htm\"<h1>Hello world!</h1>\"\n<h1>Hello world&#33;</h1>\n\n\n\n\n\n","category":"macro"}]
}
