var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This is a small suite of benchmarks for tracking the performance of the package, as well as estimating the overhead of it in comparison with the direct usage of the default backend (Hyperscript.jl). Both creation and parse times are measured.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"include(\"../../benchmark/benchmarks.jl\")\nresults = run(suite)\ngroups = [\"Parse\", \"Create\", \"Backend\"]","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"info: Info\nThe benchmark tables are automatically build with this documentation using HTM.jl itself. The code for generating the tables is shown below, as it is useful as an usage example of the library, but please take a look at the benchmark code and help improving it. üôè","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"You can sort rows by clicking on column headers (thanks to sorttable.js).","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using HTM\n\nhtm\"<script src=https://www.kryogenix.org/code/browser/sorttable/sorttable.js />\"","category":"page"},{"location":"benchmarks/#Runtime-and-garbage-collection","page":"Benchmarks","title":"Runtime and garbage collection","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"header = htm\"\"\"<tr>\n    <th scope=col>Code</th>\n    $(htm\"<th scope=col>$(name) time</th>\n          <th scope=col>$(name) GC</th>\" for name in groups)\n</tr>\"\"\"\n\nrows = map(results) do (code, result)\n    htm\"\"\"<tr>\n        <th scope=row><code>$(code)</code></th>\n        $(map([\"parser\", \"create\", \"direct\"]) do name\n            data = median(result[name])\n            htm\"<td>$(round(data.time / 1000, digits=2))  </td>\n                <td>$(round(data.gctime / 1000, digits=2))</td>\"\n        end)\n    </tr>\"\"\"\nend\n\nhtm\"<table class=sortable>\n    <caption>Median run- and garbage collection times (in ¬µs)</caption>\n    <thead>$(header)</thead>\n    <tbody>$(rows)</tbody>\n</table>\"","category":"page"},{"location":"benchmarks/#Memory-usage-and-number-of-allocations","page":"Benchmarks","title":"Memory usage and number of allocations","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"header = htm\"\"\"<tr>\n    <th scope=col>Code</th>\n    $(htm\"<th scope=col>$(name) mem.</th>\n          <th scope=col>$(name) alloc.</th>\" for name in groups)\n</tr>\"\"\"\n\nrows = map(results) do (code, result)\n    htm\"\"\"<tr>\n        <th scope=row><code>$(code)</code></th>\n        $(map([\"parser\", \"create\", \"direct\"]) do name\n            data = median(result[name])\n            htm\"<td>$(round(data.memory / 1000, digits=2))</td>\n                <td>$(data.allocs)</td>\"\n        end)\n    </tr>\"\"\"\nend\n\nhtm\"<table class=sortable>\n    <caption>Median memory usage (in kB) and number of allocations</caption>\n    <thead>$(header)</thead>\n    <tbody>$(rows)</tbody>\n</table>\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"DocTestSetup = quote\n    using HTM\n\n    üçç() = htm\"<img src=$(pineapple) />\"\nend","category":"page"},{"location":"usage/#Usage-guide","page":"Usage","title":"Usage guide","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"HTM.jl provides a non-standard string literal macro (@htm_str) for generating HTML with a syntax inspired by htm, JSX, and others. HTM.jl interpolates embedded Julia expressions based on context:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM\n\n# Photograph by Suniltg at Wikimedia Commons, distributed under a CC-BY 3.0 license.\npineapple = \"https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/%E0%B4%95%E0%B5%88%E0%B4%A4%E0%B4%9A%E0%B5%8D%E0%B4%9A%E0%B4%95%E0%B5%8D%E0%B4%95.jpg/800px-%E0%B4%95%E0%B5%88%E0%B4%A4%E0%B4%9A%E0%B5%8D%E0%B4%9A%E0%B4%95%E0%B5%8D%E0%B4%95.jpg\"  # hide\nüçç() = htm\"<img src=$(pineapple) />\"\nhtm\"<p><a href=$(pineapple)>$(üçç())</a></p>\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"What follows is a step-by-step guide of its main features.","category":"page"},{"location":"usage/#Basic-features","page":"Usage","title":"Basic features","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"HTM.jl parses markup as nodes, String (or any object in general), or nothing:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> htm\"<div>üçç</div>\"\n<div>üçç</div>","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> htm\"üçç\"\n\"üçç\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> htm\"\" === nothing\ntrue","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Multiple top-level elements (\"document fragments\") are represented as arrays:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> htm\"<div /><div />\"\n2-element Vector{Hyperscript.Node{Hyperscript.HTMLSVG}}:\n <div></div>\n <div></div>","category":"page"},{"location":"usage/#Objects-as-elements","page":"Usage","title":"Objects as elements","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Embedded Julia expressions are interpolated appropriately, allowing automatic processing and non-serializable objects. The backend (Hyperscript.jl by default) will usually use Julia's display system to render anything showable as HTML:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\nusing Plots\n\ndefault(size=(250, 250))  # hide\n# Graph simplified from <https://www.desmos.com/calculator/eds5nef5cj>.\np = begin\n    plot!(Œ∏ -> 30.4 / (2 + sin(Œ∏)) - 9.5, 0, 2œÄ, color=:brown, proj=:polar, legend=nothing)\n    for (a, b) in zip([-4  , 3  ,  9.6, 16.2, 22.7, 29.2, 35.7],\n                      [ 0.4, 6.3, 12.3, 18.3, 24.4, 30.5, 36.5])\n        plot!(Œ∏ -> Œ∏ / 2 + 2sin(4œÄ * Œ∏), a, b, color=:orange)\n    end\n    plot!(Œ∏ -> 7(1 - sin(11Œ∏)), 0.12, 3, color=:green)\nend\n\npineapple = \"https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/%E0%B4%95%E0%B5%88%E0%B4%A4%E0%B4%9A%E0%B5%8D%E0%B4%9A%E0%B4%95%E0%B5%8D%E0%B4%95.jpg/800px-%E0%B4%95%E0%B5%88%E0%B4%A4%E0%B4%9A%E0%B5%8D%E0%B4%9A%E0%B4%95%E0%B5%8D%E0%B4%95.jpg\"  # hide\nüçç() = htm\"<img src=$(pineapple) />\"  # hide\nhtm\"\"\"<div style=\"display: flex\">\n    <div style=\"transform: rotate(5deg)\">$(p)</div>\n    <div style=\"max-width: 50%\">$(üçç())</div>\n</div>\"\"\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"So if you have a function that generates an element (say by using HTM.jl), you can embed the result into another element:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\n\norange(text) = htm\"<span style=\\\"background: orange\\\">$(text)</span>\"\nhtm\"<p><strong>This is $(orange(\\\"really\\\")) important.</strong></p>\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Contrary to JSX or Hypertext Literal, HTM.jl allows you to interpolate tags as well:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> htm\"<h$(4)>I'm a header<//>\"\n<h4>I&#39;m a header</h4>","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"info: Info\nThe universal end-tag <//> above is a convenience taken from htm.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Escaping is left to the backend, which works really nice by default:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> htm\"<p>Look, Ma, $(\\\"<em>automatic escaping</em>\\\")!</p>\"\n<p>Look, Ma, &#60;em&#62;automatic escaping&#60;/em&#62;&#33;</p>","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that nothing elements are not rendered by the default backend:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\n\nhtm\"<p><strong>There's no $(nothing) here.</strong></p>\"","category":"page"},{"location":"usage/#Iterable-objects","page":"Usage","title":"Iterable objects","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"You can interpolate iterables into data, too, even iterables of elements:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\n\nhtm\"<p><strong>Easy as $([1, 2, 3])</strong></p>\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"That is useful for mapping data to content via map or by broadcasting:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\nusing Colors\n\n# Example taken from <https://observablehq.com/@observablehq/htl>.\nrows = map(enumerate(colormap(\"Oranges\", 5))) do (i, color)\n    htm\"\"\"<tr>\n        <td>$(i)</td>\n        <td><code>#$(hex(color))</code></td>\n        <td style=\"background: #$(hex(color));\"></td>\n    </tr>\"\"\"\nend\n\nheader = htm\"\"\"<tr>\n    $(htm\"<th>$(column)</th>\" for column in [\"#\", \"Color\", \"Swatch\"])\n</tr>\"\"\"\n\nhtm\"\"\"<table>\n    <caption>Five shades of üçç</caption>\n    <thead>$(header)</thead>\n    <tbody>$(rows)</tbody>\n</table>\"\"\"","category":"page"},{"location":"usage/#Optional-attributes","page":"Usage","title":"Optional attributes","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"If an attribute value is false, it's as if the attribute hadn't been specified. Conversely, if an attribute value is true, it's equivalent to the empty string. This is useful for setting an attribute based on a boolean flag:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\n\nhtm\"<p><button disabled=$(true)>Can't click me</button></p>\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"nothing attributes behave the same as false:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\n\nhtm\"<p><button disabled=$(nothing)>Can click me</button></p>\"","category":"page"},{"location":"usage/#Spread-attributes","page":"Usage","title":"Spread attributes","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"You can set multiple attributes by interpolating a dictionary in place of attributes:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\n\nattrs = Dict(\n    \"onmouseover\" => \"this.style.transform = 'rotate(5deg)'\",\n    \"onmousedown\" => \"this.style.transform = 'rotate(25deg)'\",\n    \"onmouseup\" => \"this.style.transform = 'rotate(5deg)'\",\n    \"onmouseout\" => \"this.style.transform = ''\",\n    \"onclick\" => \"alert('You clicked! üççüéâ')\",\n)\n\nhtm\"<p><button $(attrs)>Click me</button></p>\"","category":"page"},{"location":"usage/#Why-not-concatenate?","page":"Usage","title":"Why not concatenate?","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Indeed the simplest way to generate web content is to write HTML. Yet, simple concatenation has two significant drawbacks:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"It confounds markup with text and other content: if an interpolated value happens to include characters that are meaningful markup, the result may render unexpectedly. An ampersand (&) can be interpreted as a character entity reference, for instance:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"currencies = \"dollars&pounds\"\n\nHTML(\"<p><strong>My favorite currencies are $(currencies).</strong></p>\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Compare the above with the following:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM  # hide\ncurrencies = \"dollars&pounds\"  # hide\n\nhtm\"<p><strong>My favorite currencies are $(currencies).</strong></p>\"","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"You lose composition: interpolated content must be serialized as markup. You cannot combine literal HTML with content created by libraries such as Plots.jl. And some content can't be serialized:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using HTM, Plots  # hide\n\nHTML(\"<p style=\\\"display:   inline-block; transform: rotate(180deg)\\\">\n    üçç\n    $(plot(x -> x^2, -1, 1))\n</p>\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The above is probably not what you want.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"DocTestSetup = quote\n    using HTM\nend","category":"page"},{"location":"design/#How-does-it-work","page":"Design","title":"How does it work","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"HTM.jl follows Hypertext Literal by implementing a subset of the HTML5 tokenizer state machine (as well as a subset of the JSX draft specification). This allows it to distinguish different contexts such as tags and attributes, allowing embedded expressions to be interpreted correctly. Unlike regular string interpolation, HTM.jl directly creates content rather than reusable templates.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"I also wanted to minimize new syntax. The main inspiration was htm and, like htm, HTM.jl attempts to emulate JSX‚Äìnot quite HTML5‚Äìrequiring closing tags for every element.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Parsing happens at compile time and code generated by the macro builds an element tree:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> @macroexpand htm\"<span />\"\n:(create_element(processtag([\"span\"]), Dict{String, Any}(), Any[]))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The overhead is small when compared to using Hyperscript.jl directly:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> using BenchmarkTools\n\njulia> @btime htm\"<span />\"\n  273.394 ns (8 allocations: 880 bytes)\n<span></span>\n\njulia> using Hyperscript\n\njulia> @btime m(\"span\")\n  249.731 ns (7 allocations: 800 bytes)\n<span></span>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"But parsing is quite fast too:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> using BenchmarkTools  # hide\n\njulia> @btime HTM.parse(\"<span />\");\n  800.222 ns (24 allocations: 1.19 KiB)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"This approach requires scanning the input, but the state machine is reasonably fast (see Benchmarks for a more complete comparison, including memory usage).","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For a closer look at the implementation, please view the source and let me know what you think. Please help me improve it by sharing your feedback. Your contributions and bug reports are welcome on GitHub. üôè","category":"page"},{"location":"related/#Related-open-source-packages","page":"Related packages","title":"Related open-source packages","text":"","category":"section"},{"location":"related/","page":"Related packages","title":"Related packages","text":"The following open-source packages provide similar or extended functionality as HTM.jl:","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"HypertextLiteral.jl offers a similar syntax and idea.\nAcuteML.jl provides a distinct but related idea.","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"The following open-source packages are possible backends (not thoroughly tested):","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"Hyperscript.jl is the default backend\nWebIO.jl\nHiccup.jl","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"The following open-source packages extend and play nice with HTM.jl:","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"JSExpr.jl offer an elegant way of writing JavaScript.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\n\nlet md = read(\"../../README.md\", String)\n    md = replace(md, \"```julia\" => \"```julia-repl\")\n    Markdown.parse(md)\nend","category":"page"},{"location":"autodocs/","page":"Internals","title":"Internals","text":"CurrentModule = HTM","category":"page"},{"location":"autodocs/#Docstrings","page":"Internals","title":"Docstrings","text":"","category":"section"},{"location":"autodocs/","page":"Internals","title":"Internals","text":"Modules = [HTM]","category":"page"},{"location":"autodocs/#HTM.Node","page":"Internals","title":"HTM.Node","text":"Node(tag, attrs, promises=String[], children=Union{String, HTM.Node}[])\n\nCompile time internal representation of an HTML node.\n\njulia> HTM.Node([\"div\"], Dict(\"class\" => [\"fruit\"]), [], [\"üçç\"])\nHTM.Node([\"div\"], Dict(\"class\" => [\"fruit\"]), String[], Union{String, HTM.Node}[\"üçç\"])\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#Base.readuntil-Tuple{Any, IO}","page":"Internals","title":"Base.readuntil","text":"readuntil(predicate, io::IO)\n\nRead characters until matching a predicate.\n\nBased on this.\n\njulia> readuntil(isspace, IOBuffer(\"pineapple: üçç...\"))\n\"pineapple:\"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.startswith-Tuple{IO, Union{AbstractChar, AbstractString, Tuple{Vararg{AbstractChar, N} where N}, Set{var\"#s77\"} where var\"#s77\"<:AbstractChar, AbstractVector{var\"#s78\"} where var\"#s78\"<:AbstractChar}}","page":"Internals","title":"Base.startswith","text":"startswith(io::IO, prefix::Union{AbstractString,Base.Chars})\n\nCheck if an IO object starts with a prefix.\n\nBased on this.\n\njulia> io = IOBuffer(\"pineapple: üçç...\");\n\njulia> startswith(io, \"pine\")\ntrue\n\njulia> startswith(io, \"apple\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.create_element-Tuple{Any, Any, Vararg{Any, N} where N}","page":"Internals","title":"HTM.create_element","text":"create_element(tag, attrs[, children...])\n\nCreate a Hyperscript.jl element.\n\nThis is an alternative syntax and (currently) serves as a rather trivial absctraction layer inspired by React.createElement.\n\njulia> create_element(\"div\", Dict(\"class\" => \"fruit\"), \"üçç\")\n<div class=\"fruit\">üçç</div>\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parse-Tuple{IO}","page":"Internals","title":"HTM.parse","text":"parse(s::AbstractString)\nparse(io::IO)\n\nParse HTML.\n\njulia> HTM.parse(\"pineapple: <div class=\\\"fruit\\\">üçç</div>...\")\n3-element Vector{Union{String, HTM.Node}}:\n \"pineapple: \"\n HTM.Node([\"div\"], Dict(\"class\" => [\"fruit\"]), String[], Union{String, HTM.Node}[\"üçç\"])\n \"...\"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parseattrs-Tuple{IO}","page":"Internals","title":"HTM.parseattrs","text":"parseattrs(io::IO)\n\nParse HTML attributes of a node. The returned tuple contains both true attributes and promisses.\n\njulia> HTM.parseattrs(IOBuffer(\"class=\\\"fruit\\\">üçç...\"))\n(Dict(\"class\" => [\"fruit\"]), String[])\n\njulia> HTM.parseattrs(IOBuffer(\"class=\\\"fruit\\\" \\$(attrs)>üçç...\"))\n(Dict(\"class\" => [\"fruit\"]), [\"\\$(attrs)\"])\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parseelem-Tuple{IO}","page":"Internals","title":"HTM.parseelem","text":"parseelem(io::IO)\n\nParse a single HTML element.\n\njulia> HTM.parseelem(IOBuffer(\"pineapple: <div class=\\\"fruit\\\">üçç</div>...\"))\n\"pineapple: \"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parseelems-Tuple{IO}","page":"Internals","title":"HTM.parseelems","text":"parseelems(io::IO)\n\nParse HTML elements.\n\nThis function is the entry point for an implementation of a subset of the HTML standard.\n\njulia> HTM.parseelems(IOBuffer(\"pineapple: <div class=\\\"fruit\\\">üçç</div>...\"))\n3-element Vector{Union{String, HTM.Node}}:\n \"pineapple: \"\n HTM.Node([\"div\"], Dict(\"class\" => [\"fruit\"]), String[], Union{String, HTM.Node}[\"üçç\"])\n \"...\"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parseinterp-Tuple{IO}","page":"Internals","title":"HTM.parseinterp","text":"parseinterp(io::IO)\nparseinterp(fallback, io::IO)\n\nParse an interpolation as string, including $.\n\nThe input must start with $ if no fallback function is given. The fallback function is passed to readuntil if the input does not start with $.\n\njulia> HTM.parseinterp(IOBuffer(raw\"$((1, (2, 3)))...\"))\n\"\\$((1, (2, 3)))\"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parsekey-Tuple{IO}","page":"Internals","title":"HTM.parsekey","text":"parsekey(io::IO)\n\nParse an HTML attribute key.\n\njulia> HTM.parsekey(IOBuffer(\"class=\\\"fruit\\\">üçç...\"))\n\"class\"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parsenode-Tuple{IO}","page":"Internals","title":"HTM.parsenode","text":"parsenode(io::IO)\n\nParse a Node object.\n\njulia> HTM.parsenode(IOBuffer(\"<div class=\\\"fruit\\\">üçç</div>...\"))\nHTM.Node([\"div\"], Dict(\"class\" => [\"fruit\"]), String[], Union{String, HTM.Node}[\"üçç\"])\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parsetag-Tuple{IO}","page":"Internals","title":"HTM.parsetag","text":"parsetag(io::IO)\n\nParse an HTML tag.\n\njulia> HTM.parsetag(IOBuffer(\"div class=\\\"fruit\\\">üçç...\"))\n1-element Vector{String}:\n \"div\"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parsevalue-Tuple{IO}","page":"Internals","title":"HTM.parsevalue","text":"parsevalue(io::IO)\n\nParse an HTML attribute value.\n\njulia> HTM.parsevalue(IOBuffer(\"\\\"fruit\\\">üçç...\"))\n1-element Vector{String}:\n \"fruit\"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.skipstartswith-Tuple{IO, Union{AbstractChar, AbstractString}}","page":"Internals","title":"HTM.skipstartswith","text":"skipstartswith(io::IO, prefix::Union{AbstractString,Base.Chars})\n\nCheck if an IO object starts with a prefix and skip it.\n\njulia> io = IOBuffer(\"pineapple: üçç...\");\n\njulia> HTM.skipstartswith(io, \"pine\")\ntrue\n\njulia> read(io, String)\n\"apple: üçç...\"\n\njulia> io = IOBuffer(\"pineapple: üçç...\");\n\njulia> HTM.skipstartswith(io, \"apple\")\nfalse\n\njulia> read(io, String)\n\"pineapple: üçç...\"\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"autodocs/","page":"Internals","title":"Internals","text":"","category":"page"}]
}
