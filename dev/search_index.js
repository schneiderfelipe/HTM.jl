var documenterSearchIndex = {"docs":
[{"location":"guide/","page":"Guide","title":"Guide","text":"DocTestSetup = quote\n    using HTM\n\n    struct Link{H,C}\n        href::H\n        children::C\n    end\n    Base.show(io::IO, mime::MIME\"text/html\", a::Link) = show(io, mime, htm\"<a href=$(a.href)>$(a.children)</a>\")\nend","category":"page"},{"location":"guide/#Package-guide","page":"Guide","title":"Package guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"HTM.jl provides a single Julia macro, @htm_str for generating HTML with a syntax inspired by lit-html and HTM. HTM.jl is a tagged template literal for HTML that interpolates values based on context, allowing automatic escaping and the interpolation of non-serializable values, such as event listeners, style objects, and other HTML nodes and showable objects.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> using HTM\n\njulia> whom = \"üåç!\";\n\njulia> htm\"<h1>Hello, $(whom)</h1>\"\n<h1>Hello, üåç&#33;</h1>","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"What follows is a step-by-step guide of all its functionalities. This guide closely follows the guide for observablehq/htl [1].","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"[1]: A guide for observablehq/htl","category":"page"},{"location":"guide/#Why-not-concatenate?","page":"Guide","title":"Why not concatenate?","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Surely the simplest way to generate web content is to write HTML. Julia makes it easier to interpolate values into literal HTML thanks to the HTML type:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> whom = \"üåç\";\n\njulia> HTML(\"<h1>Hello $(whom)</h1>\")\nHTML{String}(\"<h1>Hello üåç</h1>\")","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"(You can't use the html\"...\" syntax here because the @html_str macro doesn't support interpolation.) Yet simple concatenation has two significant drawbacks.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"First, it confounds markup with text and other content. If an interpolated value happens to include characters that are meaningful markup, the result may render unexpectedly. An ampersand (&) can be interpreted as a character entity reference, for instance.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"value2 = \"dollars&pounds\";\nHTML(\"My favorite currencies are $(value2).\")","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"This can be fixed by escaping (say replacing ampersands with the corresponding entity, &amp;). But you must remember to escape every time you interpolate, which is tedious! And it's easy to forget when many values work as intended without it.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"safe_value2 = replace(\"dollars&pounds\", r\"&\" => \"&amp;\")\nHTML(\"My favorite currencies are $(safe_value2).\")","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Second, concatenation impedes composition: interpolated content must be serialized as markup. You cannot combine literal HTML with content created by libraries such as Plots.jl. And some content, such as event listeners implemented as closures through JSExpr.jl, can't be serialized!","category":"page"},{"location":"guide/#Features-(HTML)","page":"Guide","title":"Features (HTML)","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"HTM.jl is a tagged template literal that renders the specified markup as an element, text node, or nothing as appropriate.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"<em>I'm an element!</em>\"\n<em>I&#39;m an element&#33;</em>","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"I'm simply text.\"\n\"I'm simply text.\"","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"\" === nothing\ntrue","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"If multiple top-level nodes are given, the nodes are returned as a \"document fragment\" (a tuple).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"I'm a <em>document fragment</em> (actually a tuple).\"\n(\"I'm a \", <em>document fragment</em>, \" (actually a tuple).\")","category":"page"},{"location":"guide/#Automatic-escaping-and-interpolation","page":"Guide","title":"Automatic escaping and interpolation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"If a value is interpolated into an attribute value or data, it is escaped appropriately so as to not change the structure of the surrounding markup. This works thanks to Hyperscript.jl.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"<span>Look, Ma, $(\\\"<em>automatic escaping</em>\\\")!</span>\"\n<span>Look, Ma, &#60;em&#62;automatic escaping&#60;/em&#62;&#33;</span>","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"<font color=$(\\\"red\\\")>This text has color.</font>\"\n<font color=\"red\">This text has color.</font>","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"In cases where it is not possible to interpolate safely, namely with script and style elements where the interpolated value contains the corresponding end tag, an error is thrown.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"<script>$(\\\"</script>\\\")</script>\"  # BUG: not what should happen\n<script>&#60;/script&#62;</script>","category":"page"},{"location":"guide/#Boolean-attributes","page":"Guide","title":"Boolean attributes","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"If an attribute value is false, it's as if the attribute hadn't been specified. If an attribute value is true, it's equivalent to the empty string.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\n\nhtm\"<button disabled=$(true)>Can't click me</button>\"","category":"page"},{"location":"guide/#Optional-values","page":"Guide","title":"Optional values","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"If an attribute value is nothing or missing, it's as if the attribute hadn't been specified. If a data value is nothing or missing, nothing is embedded.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"TODO: correct behavior for missing.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\n\nhtm\"<button disabled=$(nothing)>Can click me</button>\"","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\n\nhtm\"<span>There's no $(nothing) here.</span>\"","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"$(htm\\\"\\\")\" === nothing  # It's nothings all the way down!\ntrue","category":"page"},{"location":"guide/#Spread-attributes","page":"Guide","title":"Spread attributes","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"MAJOR TODO","category":"page"},{"location":"guide/#Node-values","page":"Guide","title":"Node values","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"If an interpolated data value is a node, it is inserted into the result at the corresponding location. So if you have a function that generates a node (say itself using HTM.jl), you can embed the result into another HTM.jl.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\n\nemphasize(text) = htm\"<em>$(text)</em>\"\n\nhtm\"<span>This is $(emphasize(\\\"really\\\")) important.</span>\"","category":"page"},{"location":"guide/#Iterable-values","page":"Guide","title":"Iterable values","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can interpolate iterables into data, too, even iterables of nodes. This is useful for mapping data to content via map. Typically, you should use html.fragment for the embedded expressions.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\n\ncolorscheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\",\n               \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"]\n\nrows = map(enumerate(colorscheme)) do (i, color)\n    htm\"<tr>\n        <td>$(i)</td>\n        <td>$(color)</td>\n        <td style=\\\"background: $(color);\\\"></td>\n    </tr>\"\nend\n\nhtm\"\"\"<table>\n    <thead><tr><th>#</th><th>Color</th><th>Swatch</th></tr></thead>\n    <tbody>$(rows)</tbody>\n</table>\"\"\"","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"<span>It's as easy as $([1, 2, 3]).</span>\"\n<span>It&#39;s as easy as 123.</span>","category":"page"},{"location":"guide/#Errors-on-invalid-bindings","page":"Guide","title":"Errors on invalid bindings","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"TODO: this will probably be removed","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"HTM.jl tolerates malformed input‚Äìper the HTML5 specification‚Äìbut it still tries to be helpful by throwing an error if you interpolate a value into an unexpected place.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"TODO: this is different from htl","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\n\ntag = \"button\"\n\nhtm\"<$(tag)>This does work!</$(tag)>\"","category":"page"},{"location":"guide/#SVG","page":"Guide","title":"SVG","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can create contextual SVG fragments using HTM.jl, too.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\n\nwidth, height = 100, 100\nradius = 40\ncolor = \"red\"\n\nhtm\"<svg width=$(width) height=$(height)>\n  $(htm\\\"<circle\n            cx=$(width / 2)\n            cy=$(height / 2)\n            r=$radius\n            fill=$color\n         ></circle>\\\")\n</svg>\"","category":"page"},{"location":"guide/#CSS","page":"Guide","title":"CSS","text":"","category":"section"},{"location":"guide/#Inline-styles","page":"Guide","title":"Inline styles","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can interpolate into a style attribute as a string, but use caution: automatic escaping will still allow you to set multiple style properties this way, or to generate invalid CSS.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"\"\"<span style=\"background: $(\"yellow; font-style: italic\");\">It's yellow (and italic).</span>\"\"\"\n<span style=\"background: yellow; font-style: italic;\">It&#39;s yellow &#40;and italic&#41;.</span>","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"TODO: the following requires special treatment, doesn't currently work as indicated.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"You can safely interpolate into style properties, too, by specifying the style attribute as a Dict:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"\"\"<span style=$(Dict(\"background\" => \"yellow\"))>It's all yellow!</span>\"\"\"\n<span style=\"Dict{String, Any}(&#34;background&#34; =&#62; &#34;yellow&#34;)\">It&#39;s all yellow&#33;</span>","category":"page"},{"location":"guide/#style-tags","page":"Guide","title":"style tags","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"TODO","category":"page"},{"location":"guide/#JavaScript","page":"Guide","title":"JavaScript","text":"","category":"section"},{"location":"guide/#Function-attributes","page":"Guide","title":"Function attributes","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"If an attribute value is a function, it is assigned as a property. This can be used to register event listeners.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"TODO: this does not quite work as said (expressions, not functions, are handled).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\nusing JSExpr\n\nhtm\"\"\"<button onclick=$(@js (() -> alert(\"Hello üåç!\"))())>Click me</button>\"\"\"","category":"page"},{"location":"guide/#script-tags","page":"Guide","title":"script tags","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"using HTM  # hide\nusing JSExpr\n\nsval = \"Say \\\"Hello\\\"!\";\n\n# TODO: this requires not escaping script tags\n\nhtm\"<script>$(@js begin\n    @var x = $sval\n    alert(x)\nend)</script>\"","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"<script>\n    // Should be\n    var x = \"Say \\\"Hello\\\"!\";\n    alert(x);\n</script>","category":"page"},{"location":"guide/#Components","page":"Guide","title":"Components","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Julia already has a component concept: it is called the display convention. You just have to have Base.show overloaded for text/html (and maybe text/plain).","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"Especifically, the way of doing components is through functions and structures. A function could work as follows:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> mycomponent(name) = htm\"<div>My name is $(name).</div>\"\nmycomponent (generic function with 1 method)\n\njulia> const app = htm\"$(mycomponent(\\\"John Doe\\\"))\"\n<div>My name is John Doe.</div>","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"For a structure, you would to overload Base.show for text/html:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> struct Link{H,C}\n           href::H\n           children::C\n       end\n\njulia> Base.show(io::IO, mime::MIME\"text/html\", a::Link) =\n           show(io, mime, htm\"<a href=$(a.href)>$(a.children)</a>\")\n\njulia> htm\"\"\"<em>$(Link(\"http://bit.ly/htm-jl\", \"HTM.jl\"))</em>\"\"\"\n<em><a href=\"http://bit.ly/htm-jl\">HTM.jl</a></em>","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"If your object is the single one parsed, Base.show  for text/plain will be called. You can adjust the printing in this case by overloading Base.show for this, maybe falling back to the one above:","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"julia> htm\"\"\"$(Link(\"http://bit.ly/htm-jl\", \"HTM.jl\"))\"\"\"\nLink{String, String}(\"http://bit.ly/htm-jl\", \"HTM.jl\")\n\njulia> Base.show(io::IO, mime::MIME\"text/plain\", a::Link) =\n           show(io, MIME(\"text/html\"), a)\n\njulia> htm\"\"\"$(Link(\"http://example.com\", \"Some Text\"))\"\"\"\n<a href=\"http://example.com\">Some Text</a>","category":"page"},{"location":"guide/#Guide-roadmap","page":"Guide","title":"Guide roadmap","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"[ ] Compare with Hyperscript.jl in the documentation.\n[ ] Using JSExpr.jl with HTM.jl\n[ ] Separate things in basics and advanced","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"DocTestSetup = quote\n    using HTM\nend","category":"page"},{"location":"design/#How-does-it-work","page":"Design","title":"How does it work","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Under the hood, HTM.jl mimicks observablehq/htl by implementing a subset of the HTML5 tokenizer state machine (TODO link to HTML5 specification). This allows HTM.jl to distinguish different contexts such as tags and attributes, allowing embedded expressions to be interpreted correctly. This is more formal (and more precise) than using regular expressions to search for \"attribute-like sequences\" in markup. And while our approach requires scanning the input, the state machine is pretty fast.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Better yet, the parsing happens at compile time, so there's almost no overhead when comparing with e.g. using Hyperscript.jl directly:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> using BenchmarkTools\n\njulia> @btime htm\"<span />\"\n  273.394 ns (8 allocations: 880 bytes)\n<span></span>\n\njulia> using Hyperscript\n\njulia> @btime m(\"span\")\n  249.731 ns (7 allocations: 800 bytes)\n<span></span>","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The actual parsing happens at compile time, and the code generated by the macro actually builds a complete tree.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> @macroexpand htm\"<span />\"\n:(create_element(\"span\", (), ()))","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The parsing processing is actually fast too:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"julia> @btime HTM.parse(\"<span />\");\n  866.435 ns (24 allocations: 1.19 KiB)","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"And unlike regular string interpolation, HTM.jl directly creates content rather than reusable templates. HTM.jl is thus well-suited to reactive environments, where HTML is automatically generated when inputs change.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"We also wanted to minimize new syntax. We were inspired by HTM, but HTM emulates JSX‚Äìnot HTML5‚Äìrequiring closing tags for every element.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"For a closer look at our implementation, please view the source and let us know what you think! We welcome your contributions and bug reports on GitHub.","category":"page"},{"location":"related/#Related-open-source-packages","page":"Related packages","title":"Related open-source packages","text":"","category":"section"},{"location":"related/","page":"Related packages","title":"Related packages","text":"The following open-source packages provide similar or even extended functionality as HTM.jl:","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"HypertextLiteral.jl offers a similar but alternative syntax.\nAcuteML.jl provides a distinct but related idea.","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"The following open-source packages are possible backends:","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"Hyperscript.jl\nHiccup.jl\nWebIO.jl","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"The following open-source packages extend HTM.jl and play nice with it:","category":"page"},{"location":"related/","page":"Related packages","title":"Related packages","text":"JSExpr.jl offer an elegant way of writing JavaScript.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\n\nMarkdown.parse_file(\"../../README.md\")","category":"page"},{"location":"autodocs/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = HTM","category":"page"},{"location":"autodocs/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"autodocs/","page":"Docstrings","title":"Docstrings","text":"Modules = [HTM]","category":"page"},{"location":"autodocs/#HTM.Tag","page":"Docstrings","title":"HTM.Tag","text":"Tag(type, props[, promises=(), children=()])\n\nCompile time internal representation of an HTML tag.\n\n\n\n\n\n","category":"type"},{"location":"autodocs/#Base.readuntil-Tuple{Any, IO}","page":"Docstrings","title":"Base.readuntil","text":"readuntil(predicate, io::IO)\n\nRead characters until matching a predicate.\n\nBased on https://github.com/JuliaLang/julia/issues/21355#issue-221121166.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Base.startswith-Tuple{IO, Union{AbstractChar, AbstractString, Tuple{Vararg{AbstractChar, N} where N}, Set{var\"#s77\"} where var\"#s77\"<:AbstractChar, AbstractVector{var\"#s78\"} where var\"#s78\"<:AbstractChar}}","page":"Docstrings","title":"Base.startswith","text":"startswith(io::IO, prefix::Union{AbstractString,Base.Chars})\n\nCheck if an IO object starts with a prefix.\n\nBased on https://github.com/JuliaLang/julia/issues/40616#issue-867861851.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.create_element-Tuple{Any, Vararg{Any, N} where N}","page":"Docstrings","title":"HTM.create_element","text":"create_element(type[, children...])\ncreate_element(type, props[, children...])\n\nCreate a Hyperscript.jl element.\n\nThis is an alternative syntax and (currently) serves as a rather trivial absctraction layer inspired by React.createElement.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parse-Tuple{IO}","page":"Docstrings","title":"HTM.parse","text":"parse(io::IO)\nparse(s::AbstractString)\n\nParse HTML.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parseelem-Tuple{IO}","page":"Docstrings","title":"HTM.parseelem","text":"parseelem(io::IO)\n\nParse a single HTML element.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parseelems-Tuple{IO}","page":"Docstrings","title":"HTM.parseelems","text":"parseelems(io::IO)\n\nParse HTML elements.\n\nThis function is the entry point for an implementation of a subset of the HTML standard.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parsekey-Tuple{IO}","page":"Docstrings","title":"HTM.parsekey","text":"parsekey(io::IO)\n\nParse an HTML property key.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parseprops-Tuple{IO}","page":"Docstrings","title":"HTM.parseprops","text":"parseprops(io::IO)\n\nParse HTML properties of a tag.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parsetag-Tuple{IO}","page":"Docstrings","title":"HTM.parsetag","text":"parsetag(io::IO)\n\nParse a Tag object.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parsetagtype-Tuple{IO}","page":"Docstrings","title":"HTM.parsetagtype","text":"parsetagtype(io::IO)\n\nParse an HTML tag type.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.parsevalue-Tuple{IO}","page":"Docstrings","title":"HTM.parsevalue","text":"parsevalue(io::IO)\n\nParse an HTML property value.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#HTM.skipstartswith-Tuple{IO, Union{AbstractChar, AbstractString}}","page":"Docstrings","title":"HTM.skipstartswith","text":"skipstartswith(io::IO, prefix::Union{AbstractString,Base.Chars})\n\nCheck if an IO object starts with a prefix and skip it.\n\n\n\n\n\n","category":"method"},{"location":"autodocs/#Index","page":"Docstrings","title":"Index","text":"","category":"section"},{"location":"autodocs/","page":"Docstrings","title":"Docstrings","text":"","category":"page"}]
}
